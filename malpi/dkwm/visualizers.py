# Plot results of a VAE training run or show samples from a trained VAE or MDRNN.

import os
import numpy as np
import matplotlib.pyplot as plt

def __add_ext( path, ext ):
    fname, pext = os.path.splitext( path )
    if not ext.startswith('.'):
        ext = '.' + ext
    return fname + ext

def plot_results( history, path=None, acc_name='val_acc' ):
    """ @param history: Should be the history attribute of the return value of a Keras training run.
        @param path: If not None, then save the plot as a png to path, replacing extension with '.png' if needed.
        Plot 1 will show training and validation losses and validation accuracy if available.
        Plot 2 will show reconstruction and KL Divergence validation losses if available.
    """

    plt.figure(figsize=(20,10))
    fig, ax1 = plt.subplots()

    ax = plt.subplot(211)

    # summarize history for loss and/or accuracy
    line1 = plt.plot(history['loss'], color='red')
    line2 = plt.plot(history['val_loss'], color='green')
    plt.title('model loss')
    ax1.set_ylabel('loss')
    ax1.set_xlabel('epoch')
    leg = ['train', 'validate']
    lines = line1 + line2
    if acc_name in history:
        ax2 = ax1.twinx()
        ax2.set_ylabel('accuracy')
        line3 = ax2.plot( history[acc_name], color='blue' )
        leg.append('accuracy')
        lines += line3
        # Force the axis to be at the bottom of the plot
        pos = ax.get_position()
        pos.y0 = 0.125
        ax.set_position( pos )
    ax.legend(lines, leg, loc='upper right')

    # summarize history for r_loss and kl_loss (validation only)
    r_loss = 'val_vae_r_loss'
    if r_loss not in history:
        r_loss = 'main_output_vae_r_loss'
    kl_loss = 'val_vae_kl_loss'
    if kl_loss not in history:
        kl_loss = 'main_output_vae_kl_loss'
    if kl_loss in history and r_loss in history:
        plt.subplot(212)
        plt.plot(history[r_loss])
        plt.plot(history[kl_loss])
        plt.title('R and KL Losses')
        plt.ylabel('loss')
        plt.xlabel('epoch')
        plt.legend(['R Loss', 'KL Loss'], loc='upper right')

    #fig.tight_layout()
    if path is not None:
        path = __add_ext( path, 'png' )
        plt.savefig(path)

    plt.show()

def sample_vae(vae, images, path=None):
    """ @param vae: Requires a z_dim attribute and decode and encode methods
        @param images: Numpy array with batch_size images, e.g. shape of (10, 128, 128, 3)
        @param path: If not None, then save the plot as a png to path, replacing extension with '.png' if needed.
        Plot 1: Reconstructions of randomly sampled z-values.
        Plot 2: Given images.
        Plot 3: Reconstructed versions of the given images.
    """

    z_size = vae.z_dim
    batch_size = images.shape[0]
    input_dim = images.shape[1:]

    z = np.random.normal(size=(batch_size,z_size))
    samples = vae.decode(z)
    recon = vae.decode( vae.encode(images) )

    n = batch_size
    plt.figure(figsize=(20, 6), tight_layout=False)
    plt.title('VAE samples')
    for i in range(batch_size):
        ax = plt.subplot(3, batch_size, i+1)
        plt.imshow(samples[i].reshape(input_dim[0], input_dim[1], input_dim[2]))
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
        if 0 == i:
            ax.set_title("Random")


    for i in range(batch_size):
        ax = plt.subplot(3, batch_size, batch_size+i+1)
        plt.imshow(images[i].reshape(input_dim[0], input_dim[1], input_dim[2]))
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
        if 0 == i:
            ax.set_title("Real")

        ax = plt.subplot(3, batch_size, (2*batch_size)+i+1)
        plt.imshow(recon[i].reshape(input_dim[0], input_dim[1], input_dim[2]))
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
        if 0 == i:
            ax.set_title("Reconstructed")

    if path is not None:
        path = __add_ext( path, 'png' )
        plt.savefig(path)

    plt.show()

def plot_rnn_samples(originals, reconstructed, modeled, actions, path=None):
    """ @param originals: Real images
        @param reconstructed: original images encoded then decoded
        @param modeled: Images decoded from latent space generated by an MDRNN
        @param actions: Actions taken from test set for the original images
        @param path: If not None, then save the plot as a png to path, replacing extension with '.png' if needed.
        Plot 1: Real images.
        Plot 2: Reconstructed versions of the real images.
        Plot 3: Decoded MDRNN outputs with the actions as labels.
    """
    batch_size = originals.shape[0]
    input_dim = originals.shape[1:]
    plt.figure(figsize=(20, 6), tight_layout=False)
    plt.title('MDRNN samples')

    for i in range(batch_size):
        ax = plt.subplot(3, batch_size, i+1)
        plt.imshow(originals[i].reshape(input_dim[0], input_dim[1], input_dim[2]))
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
        if 0 == i:
            ax.set_title("Real")

        ax = plt.subplot(3, batch_size, batch_size+i+1)
        plt.imshow(reconstructed[i].reshape(input_dim[0], input_dim[1], input_dim[2]))
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
        if 0 == i:
            ax.set_title("Reconstructed")

        ax = plt.subplot(3, batch_size, (2*batch_size)+i+1)
        plt.imshow(modeled[i].reshape(input_dim[0], input_dim[1], input_dim[2]))
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
        ax.set_title( "[{:.2}, {:.2}]".format( actions[i][0], actions[i][1] ) )

    if path is not None:
        path = __add_ext( path, 'png' )
        plt.savefig(path)

    plt.show()
